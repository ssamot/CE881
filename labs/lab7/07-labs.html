<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../labs.css" type="text/css" />
</head>
<body>

 <div id="container">
<div class="leftNav">
<ul>
<li><a href="#lab-7-sq-lite">Lab 7: SQ Lite</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#app-score-stats">App Score Stats</a></li>
<li><a href="#sample-code">Sample Code</a></li>
<li><a href="#exercise-sorting">Exercise: Sorting</a></li>
<li><a href="#exercise-dummydb-1">Exercise: DummyDB 1</a></li>
<li><a href="#exercise-dummydb-2">Exercise: DummyDB 2</a></li>
<li><a href="#exercise-sqlitedb">Exercise: SQLiteDB</a></li>
<li><a href="#exercise-adding-dialogs">Exercise: Adding Dialogs</a></li>
<li><a href="#exercise-adding-a-service">Exercise: Adding a service</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
</ul>
</div>
<div class="main">
<h1 id="lab-7-sq-lite">Lab 7: SQ Lite</h1>
<h2 id="introduction">Introduction</h2>
<p>The aim of this lab is to gain experience of using SQLite with Android. You will begin by working with an existing App that works, but has some poor design in the code.  During the lab you will redesign it to follow the DB Interface design discussed in the lecture: this separates all the DB specific code into special data-oriented classes and interfaces, with all data access going via an instance of a DB Interface class.  This idea is conveyed in the UML diagram below:</p>
<p><img src="img9.gif" alt="UML Class Diagram for DB Interface" /> </p>
<h2 id="app-score-stats">App Score Stats</h2>
<p>The example we’ll work through is using SQLite to store statistics on the score obtained each time a game is played - except that we’ll do this in the context of a dummy app where each score is simply generated by calling a random number generator.</p>
<p>In the lecture we discussed how it was good practice to put all the DB-specific code in separate classes, and to deal only with Java objects in the main App classes.  A very significant benefit of this is the re-use that it brings.  Once we’ve developed an App in this way, the DB-specific code can immediately be re-used in a different App - in fact, for any app when we need to record high-score statistics.</p>
<h2 id="sample-code">Sample Code</h2>
<p>Begin by downloading and running the current app SQLiteActivity from .zip file <a href="../samples/SQLiteTest.zip">here</a>.</p>
<p>This is the version demonstrated in the lecture.  Experiment with running the code.  When run it should present the following buttons:</p>
<div class="figure">
<img src="img3.jpg" alt="SQLiteTest" />
<p class="caption">SQLiteTest</p>
</div>
<p>Check the operation of each one by monitoring the Log Cat using the string “SQLiteActivity Test:” as a filter.</p>
<p>Spend some time studying the code.  It already contains a Score class and a ScoreDB interface, but these are currently not used.</p>
<p>ScoreDBInterface and Score are defined as follows:</p>
<div class="figure">
<img src="ScoreDBInterface.PNG" alt="ScoreDBInterface" />
<p class="caption">ScoreDBInterface</p>
</div>
<div class="figure">
<img src="Score.PNG" alt="Score class" />
<p class="caption">Score class</p>
</div>
<p>The ScoreDBContract class is not really a contract, but just a list of all the column heading names used in the ScoreDB.  By using these constants we can be sure to always call a column header (attribute) by its correct name.</p>
<div class="figure">
<img src="ScoreDBContract.PNG" alt="ScoreDBContract" />
<p class="caption">ScoreDBContract</p>
</div>
<p>The interface definition is simple but useful: it shows all the ways in which the rest of the code in the app is allowed to interact with the database.  Note that it implements an Android class called BaseColumns which has the following definition, providing standard names for <strong>_ID</strong> and <strong>_COUNT</strong> columns.</p>
<div class="figure">
<img src="BaseColumns.PNG" alt="BaseColumns" />
<p class="caption">BaseColumns</p>
</div>
<p>We now move on to the main activity class, SQLiteActivity.  The onCreate method performs some routine initialisation, calling a method to add some buttons and setting up the layout from an XML file.</p>
<div class="figure">
<img src="Main%20Activity%20onCreate.PNG" alt="SQLiteActivity onCreate" />
<p class="caption">SQLiteActivity onCreate</p>
</div>
<p>The addButtons method of SQLiteActivity has code of the following form, where an in-line handler is added for each button.  The example shown is for the “create” button, but the others follow a similar pattern (though the code is more complex in some places).</p>
<div class="figure">
<img src="Main%20Activity%20add%20buttons.PNG" alt="Main Activity Add Buttons" />
<p class="caption">Main Activity Add Buttons</p>
</div>
<p>The final class to study is the <strong>ScoreHelper</strong> class which extends the built in SQLiteOpenHelper class.  This manages the connection with the database.  It defines useful SQL strings that will be executed on the database, and has methods that use these Strings and construct others dynamically on demand to create tables and insert data etc.  The methods for creating a table and adding an entry are shown below.  Note how they take an SQLiteDatabase object (<strong>db</strong>) as an argument passed from the calling activity.</p>
<div class="figure">
<img src="ScoreHelper%20onCreate.PNG" alt="Score Helper onCreate" />
<p class="caption">Score Helper onCreate</p>
</div>
<div class="figure">
<img src="addEntry.PNG" alt="ScoreHelper addEntry" />
<p class="caption">ScoreHelper addEntry</p>
</div>
<p>In the addEntry method note how the ContentValues object is used as a map to store the required value for each column, which is then passed to the db.insert method.</p>
<p>Now you are familar with the code, attempt the following exercies.</p>
<p> </p>
<h2 id="exercise-sorting">Exercise: Sorting</h2>
<p>Currently the score listing is not sorted.  Change the SELECT statement to return the scores in descending order.</p>
<h2 id="exercise-dummydb-1">Exercise: DummyDB 1</h2>
<p>Write a DummyDb implementation of the ScoreDB interface that stores all the Score objects in an ArrayList&lt;Score&gt;.  This will operate just like a real persistent implementation of the DummyDB, apart from the rather crucial aspect of not actually being persistent!</p>
<p>The most important methods to implement are the ones already declared in ScoreDB, but you can also add others corresponding to Create Table and Drop Table, so that every button on the GUI can be hooked up to do something.</p>
<p>After you’ve written the DummyDB class, write a separate DummyDBTest class the creates a DummyDB instance and calls each method to check it’s operation.</p>
<h2 id="exercise-dummydb-2">Exercise: DummyDB 2</h2>
<p>Now rewrite the SQLiteActivity class to use an instance of ScoreDB instead of doing much of the DB-related work in line.  See how much you can simplify this class by doing it this way.</p>
<h2 id="exercise-sqlitedb">Exercise: SQLiteDB</h2>
<p>Now write an SQLite implementation of the ScoreDB interface.  This can be based closely on the existing class ScoreHelper class, but will need some modification in order to match the ScoreDB interface.</p>
<p>In particular, note that the current version of ScoreHelper provides the db object, which is then passed back to it in method called such as addResult.  This is unnecessary.</p>
<h2 id="exercise-adding-dialogs">Exercise: Adding Dialogs</h2>
<p>Currently all the print out from the App goes to the Log Cat.  Change this so that each message goes to a Dialog which the use then has to dismiss to return to the main screen.</p>
<h2 id="exercise-adding-a-service">Exercise: Adding a service</h2>
<p>This is your chance to use a service:</p>
<ul>
<li>Create an <a href="http://developer.android.com/reference/android/app/IntentService.html">intentservice</a></li>
<li>Download some file from the internet and push a <a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html">notification</a></li>
<li>Update a db record with the file downloaded</li>
</ul>
<h2 id="summary">Summary</h2>
<p>In this lab we took some existing SQLite demo code and refactored it and further developed it to show that appropriate structuring of the DB access code can lead to clean and easy to understand code which is also highly re-usable.  Furthermore, the idea of using a dummy implementation of the database interface was also explored.  This enables to the App to be tested quickly without relying on the real DB code which often takes more effort to develop.</p>
<p> </p>
</div>
</div>
</body>
</html>